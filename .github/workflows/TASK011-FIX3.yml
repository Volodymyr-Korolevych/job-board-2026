name: TASK011-FIX3 Favorites auth via cookie or token

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  task011_fix3:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Write auth helper and patch favorites endpoints
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          from pathlib import Path

          def write(path: str, content: str):
              p = Path(path)
              p.parent.mkdir(parents=True, exist_ok=True)
              p.write_text(content, encoding="utf-8")

          write("server/utils/getUserFromEvent.ts", """import User from '~/server/models/User'
          import { H3Event } from 'h3'

          function base64UrlDecode(input: string) {
            const pad = '='.repeat((4 - (input.length % 4)) % 4)
            const b64 = (input + pad).replace(/-/g, '+').replace(/_/g, '/')
            return Buffer.from(b64, 'base64').toString('utf-8')
          }

          function safeJsonParse<T = any>(s: string): T | null {
            try {
              return JSON.parse(s) as T
            } catch {
              return null
            }
          }

          function tryReadUserFromJsonCookie(event: H3Event) {
            const c1 = getCookie(event, 'auth_user')
            const c2 = getCookie(event, 'user')
            const raw = c1 || c2
            if (!raw) return null

            const parsed = safeJsonParse<any>(raw)
            if (!parsed) return null

            // підтримка формату { user: {...} } або просто { _id, role, ... }
            const u = parsed.user || parsed
            if (u?._id) return u
            return null
          }

          function tryReadUserIdFromJwtCookie(event: H3Event) {
            const token =
              getCookie(event, 'token') ||
              getCookie(event, 'auth_token') ||
              getCookie(event, 'access_token') ||
              ''

            if (!token) return null
            const parts = token.split('.')
            if (parts.length !== 3) return null

            const payloadRaw = base64UrlDecode(parts[1])
            const payload = safeJsonParse<any>(payloadRaw)
            if (!payload) return null

            return (
              payload.sub ||
              payload.userId ||
              payload._id ||
              payload.id ||
              null
            )
          }

          export async function getUserFromEvent(event: H3Event) {
            // 1) якщо middleware уже заповнює context.user
            const ctxUser = (event.context as any).user
            if (ctxUser?._id) return ctxUser

            // 2) cookie з JSON користувачем
            const cookieUser = tryReadUserFromJsonCookie(event)
            if (cookieUser?._id) return cookieUser

            // 3) JWT cookie -> userId -> user з БД
            const userId = tryReadUserIdFromJwtCookie(event)
            if (!userId) return null

            try {
              const u: any = await User.findById(userId).lean()
              return u || null
            } catch {
              return null
            }
          }
          """)

          write("server/api/favorites.get.ts", """import Favorite from '~/server/models/Favorite'
          import Company from '~/server/models/Company'
          import { connectDB } from '~/server/utils/db'
          import { getUserFromEvent } from '~/server/utils/getUserFromEvent'

          export default defineEventHandler(async (event) => {
            await connectDB()

            const user: any = await getUserFromEvent(event)
            if (!user?._id) {
              throw createError({ statusCode: 401, statusMessage: 'Потрібна авторизація' })
            }
            if (user.role !== 'seeker') {
              throw createError({ statusCode: 403, statusMessage: 'Доступно лише для пошукача' })
            }

            const favorites: any[] = await Favorite.find({ seekerId: user._id })
              .sort({ createdAt: -1 })
              .populate('jobId')
              .lean()

            const jobs: any[] = favorites
              .map((f) => f.jobId)
              .filter(Boolean)
              .map((j) => ({ ...j }))

            const companyIds = new Set<string>()
            const ownerIds = new Set<string>()

            for (const j of jobs) {
              if (j.companyId) companyIds.add(String(j.companyId))
              if (j.employerId) ownerIds.add(String(j.employerId))
              if (j.ownerId) ownerIds.add(String(j.ownerId))
              if (j.userId) ownerIds.add(String(j.userId))
            }

            const or: any[] = []
            if (companyIds.size) or.push({ _id: { $in: Array.from(companyIds) } })
            if (ownerIds.size) or.push({ ownerId: { $in: Array.from(ownerIds) } })

            const companies: any[] = or.length ? await Company.find({ $or: or }).lean() : []
            const byId = new Map(companies.map((c) => [String(c._id), c]))
            const byOwner = new Map(companies.map((c) => [String(c.ownerId), c]))

            return favorites.map((f) => {
              const j = f.jobId
              if (!j) return { _id: String(f._id), createdAt: f.createdAt, job: null }

              const c =
                (j.companyId ? byId.get(String(j.companyId)) : null) ||
                (j.employerId ? byOwner.get(String(j.employerId)) : null) ||
                (j.ownerId ? byOwner.get(String(j.ownerId)) : null) ||
                (j.userId ? byOwner.get(String(j.userId)) : null)

              return {
                _id: String(f._id),
                createdAt: f.createdAt,
                job: {
                  ...j,
                  companyName: c?.name || '',
                  companyPhone: c?.phone || ''
                }
              }
            })
          })
          """)

          write("server/api/favorites.post.ts", """import Favorite from '~/server/models/Favorite'
          import { connectDB } from '~/server/utils/db'
          import { getUserFromEvent } from '~/server/utils/getUserFromEvent'

          export default defineEventHandler(async (event) => {
            await connectDB()

            const user: any = await getUserFromEvent(event)
            if (!user?._id) {
              throw createError({ statusCode: 401, statusMessage: 'Потрібна авторизація' })
            }
            if (user.role !== 'seeker') {
              throw createError({ statusCode: 403, statusMessage: 'Доступно лише для пошукача' })
            }

            const body = await readBody(event)
            const jobId = body?.jobId ? String(body.jobId) : ''
            if (!jobId) {
              throw createError({ statusCode: 400, statusMessage: 'Не вказано jobId' })
            }

            try {
              const fav = await Favorite.create({ seekerId: user._id, jobId })
              return { ok: true, favoriteId: String(fav._id) }
            } catch (e: any) {
              if (String(e?.code) == '11000') return { ok: true, already: true }
              throw createError({ statusCode: 500, statusMessage: 'Не вдалося додати в обране' })
            }
          })
          """)

          write("server/api/favorites.delete.ts", """import Favorite from '~/server/models/Favorite'
          import { connectDB } from '~/server/utils/db'
          import { getUserFromEvent } from '~/server/utils/getUserFromEvent'

          export default defineEventHandler(async (event) => {
            await connectDB()

            const user: any = await getUserFromEvent(event)
            if (!user?._id) {
              throw createError({ statusCode: 401, statusMessage: 'Потрібна авторизація' })
            }
            if (user.role !== 'seeker') {
              throw createError({ statusCode: 403, statusMessage: 'Доступно лише для пошукача' })
            }

            const body = await readBody(event)
            const favoriteId = body?.favoriteId ? String(body.favoriteId) : ''
            const jobId = body?.jobId ? String(body.jobId) : ''

            if (!favoriteId && !jobId) {
              throw createError({ statusCode: 400, statusMessage: 'Не вказано favoriteId або jobId' })
            }

            if (favoriteId) {
              const res = await Favorite.deleteOne({ _id: favoriteId, seekerId: user._id })
              return { ok: true, deletedCount: res.deletedCount || 0 }
            }

            const res = await Favorite.deleteOne({ seekerId: user._id, jobId })
            return { ok: true, deletedCount: res.deletedCount || 0 }
          })
          """)
          PY

      - name: Commit and push
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add server/utils/getUserFromEvent.ts server/api/favorites.get.ts server/api/favorites.post.ts server/api/favorites.delete.ts
          git commit -m "TASK011-FIX3: favorites auth via event context or cookies/tokens" || echo "No changes"
          git push
